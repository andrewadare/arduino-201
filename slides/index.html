<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Arduino 201 @ SSD</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"><link rel="stylesheet" href="reveal.js/css/reveal.css"><link rel="stylesheet" href="css/black.css"><link rel="stylesheet" href="css/monokai-sublime.css"></head><body><div class="reveal"><div class="slides"><section><h1>Arduino 201</h1><p style="text-align: center"><span class="ino-white"><strong>Tips for your next project</strong></span></p><p style="text-align: center">Todd Lawall and Andrew Adare</p><p style="text-align: center">December 1, 2016 @ Solid State Depot</p><aside class="notes"><ul><li>Welcome</li><li>Format for session: ~45-60 min. presentation, then hands-on</li></ul></aside></section><section><h2>The Arduino IDE</h2><p>Why we</p><div class="lefthalf"><p><span class="green">Love it</span>:</p><ul><li>Very approachable</li><li>Free and open</li><li>Community</li><li>Documentation</li><li>Diverse HW support</li></ul></div><div class="righthalf"><p><span class="red">Don't love it</span>:</p><ul><li>Lousy editor</li><li>Not-quite-C++</li><li>Bad examples around</li><li>Code can be slow</li><li><code>analogWrite</code>?</li></ul></div><br><br><p style="text-align: center">BTW: You didn't miss <span class="ino-white"><strong>"Arduino 101"</strong></span> - we skipped it.</p><aside class="notes"><ul><li>We're assuming you have your IDE set up and have some basics down.</li><li>Many examples are fine for simple tasks, but don't scale well to multitasking projects.</li></ul></aside></section><section><h2>outline</h2><p><span class="ino-orange"><strong>A few hardware preliminaries</strong></span><ul><li>Powering your project</li><li>Current considerations, large loads</li><li>Overview of MCU peripherals</li></ul></p><aside class="notes"><ul><li>Hardware: how not to zap your pins, avoiding brownouts, electronics tips go here</li></ul></aside></section><section><h2>outline</h2><p><span class="ino-orange"><strong>Host software</strong></span><ul><li>Using the Arduino CLI and your own editor</li><li>Writing custom library classes</li><li>Communicating externally</li></ul></p><aside class="notes"><ul><li>Software: how I use the IDE as a toolchain in headless mode</li><li>Firmware: bulk of the talk spent here</li></ul></aside></section><section><h2>outline</h2><p><span class="ino-orange"><strong>Firmware</strong></span><ul><li>Coding outside loop()</li><li>When and how to avoid delay()</li><li>Integer math: choosing datatypes and keeping precision</li><li>Interrupts</li><li>timer configuration and gotchas</li><li>AVR-specific hacks: registers, datasheet, AVR libc</li><li>Sleeping</li></ul></p><aside class="notes"><ul><li>Firmware: bulk of the talk spent here</li></ul></aside></section><section><h2>Powering your project</h2><ul><li>Voltage is easy to get right</li><li>Current not so much</li><li>USB can only source 500mA</li><li>Use another source if you're powering more than the Arduino</li><li>Power conflicts can occur - USB port drops off</li><li>If conflict happens, power project with a battery</li></ul></section><section><h2>Driving large loads</h2><ul><li>Each pin only drives 40mA</li><li>You cannot drive larger loads with that</li><li>E.g. An LED draws from 5mA to 20mA</li><li>You can drive the gate of a transistor</li><li>Relays usually take more current than this</li><li>Relays can be driven using a transistor, but also need a shunt diode to protect against back EMF.</li><li>Larger transistors include MOSFETs and IGBTs</li><li>Solid State Relays are an alternative</li></ul></section><section><h2>MCU Hardware overview</h2><p>Our specimen: ATMega 328P (Uno, Nano, Pro Mini, ...)</p><ul><li>20 GPIO pins, all with pin-change interrupt support</li><li>3 Timer/counter units: 0 (8 bit), 1 (16 bit), 2 (8 bit)</li><li>6 PWM channels</li><li>1 A/D converter (10 bits, 6 channels)</li><li>Serial peripherals: I2C, SPI, and USART</li><li>EEPROM</li><li>Analog Comparator</li></ul></section><section><img data-src="figs/atmega328-pinout.png"></section><section><h2>Responding to changes</h2><h4>The polling approach</h4><p>Consider the <a href="https://www.arduino.cc/en/Tutorial/StateChangeDetection">stateChangeDetection</a> example:</p><pre><code class="cpp">void loop() {
  buttonState = digitalRead(buttonPin);
  if (buttonState != lastButtonState) {
    // Conditional logic here (LOW-HIGH vs. HIGH-LOW)...
  }
  lastButtonState = buttonState;
  // Possibly several other tasks here....
}</code></pre><div class="lefthalf"><p><span class="green">Pros</span>:</p><ul><li>Straightforward</li><li>No chance of corruption</li></ul></div><div class="righthalf"><p><span class="red">Cons</span>:</p><ul><li>Delayed response</li><li>Inefficient</li><li>No priority control</li></ul></div></section><section><h2>Responding to Changes</h2><h4>The Interrupt-driven Approach</h4><pre><code class="cpp">#define BUTTON_PIN 2;
#define LED_PIN 13;

volatile uint8_t pinState = LOW;

void setup() {
  pinMode(LED_PIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), toggle, CHANGE);
}

void loop() {
  digitalWrite(LED_PIN, pinState);
}

void toggle() {
  pinState = !pinState;
}
</code></pre></section><section><h2>Two kinds of Interrupts</h2><p><span class="ino-orange">Internally triggered</span> by system events</p><ul><li>Timers, serial events, A/D complete, etc.</li><li>Arduino mostly handles these for us (<code>Serial, Wire</code>)</li></ul><p><span class="ino-orange">Externally triggered</span> by voltage changes on a pin</p><ul><li>Pin-change interrupts (available on every GPIO pin)</li><ul><li>Only fired on change, BYO logic to do more</li></ul><li>Arduino pins 2, 3 (PD2/INT0, PD3/INT1) are special:</li><ul><li>They have top priority</li><li>Dedicated HW to trigger on rise, fall, or change</li></ul><li>Both types are handled by "callbacks" called ISRs.</li></ul></section><section><img data-src="figs/interrupt-priorities.png"></section><section><h2>Interrupt Programming Guidelines:</h2><ul><li>Keep them short and sweet</li><li>put sensitive code (e.g. assignments) in a <code>noInterrupts()/interrupts()</code> block</li><li>(it's like AVR's ATOMIC_BLOCK, the most epic preprocessor definition ever)</li><li>Declare variables changed in interrupts as <code>volatile</code> so compiler doesn't optimize them away</li></ul></section><section><p style="text-align: center"><span class="ino-teal"><strong>When to use <code>delay()</code>?</strong></span></p><p><span class="ino-orange">Not often.</span> <code>delay()</code> blocks everything but interrupts. It's especially bad with polling patterns.</p><p>Better to do something like this:</p><pre><code class="cpp">unsigned long timeMarker = 0;
const unsigned long dt = 20;
void loop() {
  if (millis() - timeMarker >= dt) {
    timeMarker = millis();
    // Put code here that runs every dt milliseconds
  }
}
</code></pre><p>Teensyduino has <code>elapsedMillis</code> and <code>elapsedMicros</code> timers, which account for code run time to keep a tight schedule</p></section><section><h2>AVR Programming in Arduino</h2><p>Why defeat Arduino's hardware abstraction?</p><div class="lefthalf"><p><span class="green">Pros</span>:</p><ul><li>Fine-grained control</li><li>Significant performance gains</li><li>Transparency: WYSIWYG bare-metal code</li></ul></div><div class="righthalf"><p><span class="red">Cons</span>:</p><ul><li>Non-portable</li><li>Looks esoteric</li><li>Mixing APIs</li></ul></div></section><section><h2>Timers</h2><ul><li>Timers in AVR are more than a clock</li><li>internal clock source counting</li><li>external pin change counting</li><li>capture - timer value is copied at time of an event, like a stopwatch</li><li>compare - timer throws interrupt when a specific value is reached</li><li>When they roll over (overflow) they can fire an interrupt.</li><li>Prescaler/postscaler - these are ways to stretch out the clock</li></ul></section><section><h2>How to read the datasheet</h2><a href="http://www.atmel.com/devices/atmega328p.aspx"><img data-src="figs/atmega328-datasheet-title.png"></a><div class="lefthalf"><p>Electrical specs</p><ul><li>Current limits</li><li>Voltage limits</li></ul></div><div class="righthalf"><p>Programming aids</p><ul><li>Peripheral information</li><li>Timer/counter register tables</li><li>Interrupts</li></ul></div></section><section><h2>AVR Glibc avrfreaks</h2><p>http://www.nongnu.org/avr-libc/</p></section><section><h2>Sleep</h2><ul><li>Sleeping conserves the battery</li><li>You will need an interrupt source to wake</li><li>Don't forget the on board regulator</li></ul><p></p><a>http://playground.arduino.cc/Learning/ArduinoSleepCode</a><br><a>http://www.engblaze.com/hush-little-microprocessor-avr-and-arduino-sleep-mode-basics/</a></section><section><h2>ATMega328 PWM info</h2><p>PWM pins:</p><ul><li>5, 6 (Timer 0)</li><li>9, 10 (Timer 1)</li><li>3, 11 (Timer 2)</li></ul><p>Base frequencies:</p><ul><li>31350 Hz for pins 3, 9, 10, and 11</li><li>~62.5 kHz for pins 5, 6</li></ul><p>Default PWM frequencies:</p><ul><li>980 Hz - pins 5, 6</li><li>~490 Hz - pins 9, 10, 3, 11</li></ul></section><section><h2>ATMega328 PWM configuration</h2><p>Let's say you wish to output a PWM frequency other than the default.</p><p><span class="ino-orange">Warning:</span> changing timers affects more than one pin, and can silently change built-in functions.</p><p>Reconfiguring Timer 1 does not affect millis() or delay() (but borks the Servo library)</p></section><section><p><span class="ino-teal">Example:</span> Set up Timer 2 for phase-correct (count-up-count-down) PWM mode, with variable PWM frequency. With the WGM22 and COM2A0 bits set, OC2A toggles based on the OCR2A value.</p><p>Pin 11 frequency and duty cycle:</p><ul><li>f = 16MHz / 64 / (2*OCR2A) / 2</li><li>d = 50% (fixed)</li></ul><p>Pin 3:</p><ul><li>f = 16MHz / 64 / OCR2A / 2</li><li>d = OCR2B/OCR2A</li></ul><p>For a 500 Hz square wave on pin 3 (and 250 Hz on pin 11), use OCR2A = 250 and OCR2B = 125.</p></section><section><h2>Speeding up GPIO</h2><h4>Direct register i/o versus arduino</h4><p>AVR register R/W takes 1 instruction ($\lt$ 0.1 $\mu$s @ 16MHz)!</p><p><code class="cpp">digitalRead/Write</code> can take 50 cycles or more (4-5 us)</p><p>Timing comparison: toggle pin 4 from the CPU</p><pre><code class="cpp">void loop() {
  digitalWrite(4, !digitalRead(4)); // 56.58 kHz on my scope
}
 // vs.
void loop() {
  PORTD ^= (1 << PD4); // 444.4 kHz, ~8x faster
}
</code></pre><aside class="notes"><p>A few us often doesn't matter, but this may be enough to get you through a hotspot in your code.</p><p>Why dR and dW are slow:</p><ul><li>Function call overhead (stack address lookup)</li><li>Check if the pin is on a timer</li><li>Array lookup 1: integer pin number to port number (flash access)</li><li>Array lookup 2: port and pin number to register address (flash access)</li></ul><p>see http://www.codeproject.com/Articles/589299/Why-is-the-digital-I-O-in-Arduino-slow-and-what-ca</p></aside></section><section><h2>Math tips</h2><ul><li>always use <code>unsigned long</code> for timers</li><li>Floating-point math is slow and inefficient on AVRs (no hardware FPU).</li><li>Beware: some Arduino functions (e.g. p <code class="cpp">map</code>) use integer division internally</li><li>Scale up your ints to keep precision:</li></ul><pre><code class="cpp">// convert ADC from a turnpot to an angle in degrees
float angle = (float)map(adc, ADC_FULL_LEFT, ADC_FULL_RIGHT, 100*DEG_FULL_LEFT, 100*DEG_FULL_RIGHT)/100;
</code></pre></section><section><p style="text-align: center"><span class="ino-teal"><strong><code>analogRead</code> and Noise</strong></span></p><p>Low-pass filtering is easily implemented in firmware! Consider the <a href="http://www.itl.nist.gov/div898/handbook/pmc/section4/pmc431.htm">EWMA </a> for time-series ADC measurements $x_{t}$:</p><p>$$ S_t = \alpha x_{t−1} + (1−\alpha) S_{t−1}, \quad 0 \lt \alpha \leq 1. $$</p><p>Let's implement this with $\alpha = 1/16$ using integer math.</p><p>To improve precision, work with $16S_t$ instead of $S_t$:</p><p>$$ 16S_t = x_{t−1} + 16S_{t−1} - (16S_{t−1} - 16/2)/16 $$</p><pre><code class="cpp">void ewma(unsigned int x, unsigned int &x16)
{
  x16 = x + x16 - ((x16 - 8) >> 4);
}</code></pre><p>When using the measurement, simply divide by 16.</p></section><section><img data-src="figs/adc.svg" width="100%"></section><section><h2>The Arduino CLI</h2><p>I don't care much for Arduino as an IDE, and mainly just use it as a convenient toolchain. I have these in my .bashrc</p><pre><code class="bash">alias arduino='/Applications/Arduino.app/Contents/MacOS/Arduino'
alias uno='arduino --board arduino:avr:uno'
alias nano='arduino --board arduino:avr:nano:cpu=atmega328'
alias t3='arduino --board teensy:avr:teensy31'</code></pre><p>So I can do</p><pre><code class="bash">uno --port /dev/cu.usbmodem1234 --upload mysketch.ino</code></pre></section><section><h2>Serial Coms (arduino side)</h2><p>Setup of the hardware serial port is as simple as:<pre><code class="cpp">void setup()
{
    Serial.begin(115200);
}</code></pre></p><p>Reading from it can be done by checking for available chars<pre><code class="cpp">if( Serial.available() > 0 )
{
  Serial.readBytesUntil('\r',inputBuffer,127);
  // do something with whatever just came in
}
</code></pre></p></section><section><h2>Serial Coms (arduino side)</h2><p>Writing to the serial port is as easy as using the print() and println() methods<pre><code class="cpp">Serial.print("Hello world!");
Serial.println("Bob's your uncle!");
Serial.print(someInteger);
</code></pre></p></section><section><h2>Serial Coms (arduino side)</h2><p>Printing multiple values can be tedious, especially if you want a specific format.</p><pre><code class="cpp">Serial.print("Count is ");
Serial.print(myCounter);
Serial.print(" out of ");
Serial.println(total);
</code></pre><p>Compared to</p><pre><code class="cpp">serialPrintf("Count is %d out of %d", myCounter, total);
</code></pre></section><section><p>Serial printf version</p><pre><code class="cpp">#include <Arduino.h>
#include <stdarg.h>
#define PRINTF_BUF 80 // define the tmp buffer size (change if desired)
void serialPrintf(const char *format, ...)
{
  char buf[PRINTF_BUF];
  va_list ap;
  va_start(ap, format);
  vsnprintf(buf, sizeof(buf), format, ap);
  for(char *p = &buf[0]; *p; p++) // emulate cooked mode for newlines
  {
    if(*p == '\n')
    {
      Serial.write('\r');
    }
    Serial.write(*p);
  }
  va_end(ap);
}
</code></pre></section><section><h2>Serial Coms (host side)</h2><ul><li>For serial coms, I use the venerable <code>screen</code> utility:<pre><code class="bash">screen /dev/cu.usbmodem 115200</code></pre></li><li>If you need to edit the string before sending the characters down, use the Arduino Serial Monitor</li><li>Python <code>serial</code> module does well for programs interacting with an arduino</li></ul></section><section><h2>Scaling up or down</h2><p>The standard ATMega328 may not fit your needs.</p><ul><li>Memory may be too small</li><li>Physical size may be too big</li><li>Might not have enough computing power</li></ul><p>There are other options that the Arduino environment supports.</p></section><section><h2>ATMega Alternatives</h2><p><span class="ino-orange"><strong>32-bit systems</strong></span><ul><li>Teensy (ARM based)</li><li>Feather (ARM M0 based)</li><li>ChipKIT (PIC32 based)</li><li>ESP8266 (Tensilica based, with WiFi)</li></ul></p><p><span class="ino-orange"><strong>8-bit systems</strong></span><ul><li>ATTiny85 (smaller AVR, 8 pins)</li><li>PIC18F2550 (USB built in)</li></ul></p><a>http://playground.arduino.cc/Main/ArduinoOnOtherAtmelChips</a><br><a>https://github.com/arduino/Arduino/wiki/Unofficial-list-of-3rd-party-boards-support-urls</a></section><section><h2>Where to buy</h2><ul><li>SparkFun (one of our favorite places)</li><li>Adafruit</li><li>Seeedstudio</li><li>iTead mall</li><li>eBay (caveat emptor - faulty parts, long shipping times)</li><li>AliExpress (caveat emptor - long shipping times)</li></ul></section><section><h2>Takeaways</h2><ul><li>HW abstraction is a great thing...</li><li>But (judiciously) busting it is useful!</li><li>Stop thinking of your MCU as just a CPU with i/o pins! Program the timer/counters and interrupt system too.</li><li>Arduino is not dying out - the latest devices are still targeting the platform.</li></ul><p style="text-align: center">Thanks!!</p></section></div></div><script src="reveal.js/lib/js/head.min.js"></script><script src="reveal.js/js/reveal.js"></script><script src="init.js"></script></body></html>