<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Arduino 201 @ SSD</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"><link rel="stylesheet" href="reveal.js/css/reveal.css"><link rel="stylesheet" href="css/black.css"><link rel="stylesheet" href="css/monokai-sublime.css"></head><body><div class="reveal"><div class="slides"><section><h1>Arduino 201</h1><p style="text-align: center"><span class="ino-white"><strong>Tips for your next project</strong></span></p><p style="text-align: center">Todd Lawall and Andrew Adare</p><p style="text-align: center">December 1, 2016 @ Solid State Depot</p><aside class="notes"><ul><li>Welcome</li><li>Format for session: 1 hr presentation, then hands-on</li></ul></aside></section><section class="center"><p style="text-align: center">You didn't miss <span class="ino-white"><strong>"Arduino 101"</strong></span> - we skipped it.</p><aside class="notes"><p>We're assuming you have your IDE set up and have some basics down.</p></aside></section><section><h2>outline</h2><p><span class="ino-orange"><strong>A few hardware preliminaries</strong></span><ul><li>Powering your project</li><li>Current considerations, large loads</li><li>Overview of MCU peripherals</li><li>Signal conditioning</li></ul></p><aside class="notes"><ul><li>Hardware: how not to zap your pins, avoiding brownouts, electronics tips go here</li></ul></aside></section><section><h2>outline</h2><p><span class="ino-orange"><strong>Host software</strong></span><ul><li>Using the Arduino CLI and your own editor</li><li>Writing custom library classes</li><li>Communicating externally</li></ul></p><aside class="notes"><ul><li>Software: how I use the IDE as a toolchain in headless mode</li><li>Firmware: bulk of the talk spent here</li></ul></aside></section><section><h2>outline</h2><p><span class="ino-orange"><strong>Firmware</strong></span><ul><li>Coding outside loop()</li><li>When and how to avoid delay()</li><li>Integer math: choosing datatypes and keeping precision</li><li>Interrupts</li><li>timer configuration and gotchas</li><li>AVR-specific hacks: registers, datasheet, AVR libc definitions</li><li>Sleeping and WDT</li></ul></p><aside class="notes"><ul><li>Firmware: bulk of the talk spent here</li></ul></aside></section><section><h2>outline</h2><p><span class="ino-orange"><strong>32-bit systems</strong></span><ul><li>Arduino and ESP8266</li><li>Teensyduino</li></ul></p></section><section><h2>Powering your project</h2><p style="text-align: center">[Todd]</p></section><section><h2>Driving large loads</h2><p style="text-align: center">[up for grabs]</p></section><section><h2>MCU Hardware overview</h2><p>Specimen: ATMega 328P (Uno, Nano, Pro Mini, ...)</p><ul><li>20 GPIO pins, all with pin-change interrupt support</li><li>3 Timer/counter units: 0 (8 bit), 1 (16 bit), 2 (8 bit)</li><li>6 PWM channels</li><li>1 A/D converter (10 bits, 6 channels)</li><li>Serial peripherals: I2C, SPI, and USART</li></ul></section><section><img data-src="figs/atmega328-pinout.png"></section><section><h2>Polling for changes</h2><pre><code class="cpp">void loop()
{
  if (digitalRead(BUTTON_PIN) == LOW)
    {
      Serial.println("Button pressed");
    }
  // Other tasks here
}</code></pre><p><span class="green">Pros</span>: Simple to program and reason about</p><p><span class="red">Cons</span>: Delayed response; inefficient; no priority control</p></section><section><h2>Hardware Interrupt System</h2><pre><code class="cpp">// TODO button interrupt example</code></pre></section><section><h2>Internal and External Interrupts</h2></section><section><img data-src="figs/interrupt-priorities.png"></section><section><h2>AVR Programming</h2><p>Defeating hardware abstraction for performance and control</p></section><section><h2>GPIO speedups</h2><h4>Direct register i/o versus arduino</h4><p>AVR register R/W takes 1 instruction ($\lt$ 0.1 us @ 16MHz)!</p><p><code class="cpp">digitalRead/Write</code> takes 50 cycles or more (4-5 us)</p><ul><li>Function call overhead (stack address lookup)</li><li>Check if the pin is on a timer</li><li>Array lookup 1: integer pin number to port number (flash access)</li><li>Array lookup 2: port and pin number to register address (flash access)</li></ul><aside class="notes"><p>Do you care about 4-5us? Maybe not. But this may be enough to get you through a hotspot in your code.</p></aside></section><section><h2>Math tips</h2><ul><li>Floating-point math is slow and inefficient on AVRs (no hardware FPU).</li><li>Beware: some Arduino functions (e.g. p <code class="cpp">map</code>) use integer division internally</li><li>Scale up your ints to keep precision:</li></ul><pre><code class="cpp">// convert ADC from a turnpot to an angle in degrees
float angle = (float)map(adc, ADC_FULL_LEFT, ADC_FULL_RIGHT, 100*DEG_FULL_LEFT, 100*DEG_FULL_RIGHT)/100;</code></pre></section><section><h1>Analog Input</h1><p></p></section></div></div><script src="reveal.js/lib/js/head.min.js"></script><script src="reveal.js/js/reveal.js"></script><script src="init.js"></script></body></html>