<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Arduino 201 @ SSD</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"><link rel="stylesheet" href="reveal.js/css/reveal.css"><link rel="stylesheet" href="css/black.css"><link rel="stylesheet" href="css/monokai-sublime.css"></head><body><div class="reveal"><div class="slides"><section><h1>Arduino 201</h1><p style="text-align: center"><span class="ino-white"><strong>Tips for your next project</strong></span></p><p style="text-align: center">Todd Lawall and Andrew Adare</p><p style="text-align: center">December 1, 2016 @ Solid State Depot</p><aside class="notes"><ul><li>Welcome</li><li>Format for session: ~45-60 min. presentation, then hands-on</li></ul></aside></section><section><h2>The Arduino IDE</h2><p>Why we</p><div class="lefthalf"><p><span class="green">Love it</span>:</p><ul><li>Accessible</li><li>Free and open</li><li>Community</li><li>Documentation</li><li>Diverse HW support</li></ul></div><div class="righthalf"><p><span class="red">Don't love it</span>:</p><ul><li>Lousy editor</li><li>Not-quite-C++</li><li>Bad examples around</li><li>Code can be slow</li><li><code>analogWrite</code>?</li></ul></div><br><br><p style="text-align: center">BTW: You didn't miss <span class="ino-white"><strong>"Arduino 101"</strong></span> - we skipped it.</p><aside class="notes"><p>We're assuming you have your IDE set up and have some basics down.</p></aside></section><section><h2>outline</h2><p><span class="ino-orange"><strong>A few hardware preliminaries</strong></span><ul><li>Powering your project</li><li>Current considerations, large loads</li><li>Overview of MCU peripherals</li><li>Signal conditioning</li></ul></p><aside class="notes"><ul><li>Hardware: how not to zap your pins, avoiding brownouts, electronics tips go here</li></ul></aside></section><section><h2>outline</h2><p><span class="ino-orange"><strong>Host software</strong></span><ul><li>Using the Arduino CLI and your own editor</li><li>Writing custom library classes</li><li>Communicating externally</li></ul></p><aside class="notes"><ul><li>Software: how I use the IDE as a toolchain in headless mode</li><li>Firmware: bulk of the talk spent here</li></ul></aside></section><section><h2>outline</h2><p><span class="ino-orange"><strong>Firmware</strong></span><ul><li>Coding outside loop()</li><li>When and how to avoid delay()</li><li>Integer math: choosing datatypes and keeping precision</li><li>Interrupts</li><li>timer configuration and gotchas</li><li>AVR-specific hacks: registers, datasheet, AVR libc definitions</li><li>Sleeping and WDT</li></ul></p><aside class="notes"><ul><li>Firmware: bulk of the talk spent here</li></ul></aside></section><section><h2>outline</h2><p><span class="ino-orange"><strong>32-bit systems</strong></span><ul><li>Arduino and ESP8266</li><li>Teensyduino</li></ul></p></section><section><h2>Powering your project</h2><p style="text-align: center">[Todd]</p></section><section><h2>Driving large loads</h2><p style="text-align: center">[up for grabs]</p></section><section><h2>MCU Hardware overview</h2><p>Specimen: ATMega 328P (Uno, Nano, Pro Mini, ...)</p><ul><li>20 GPIO pins, all with pin-change interrupt support</li><li>3 Timer/counter units: 0 (8 bit), 1 (16 bit), 2 (8 bit)</li><li>6 PWM channels</li><li>1 A/D converter (10 bits, 6 channels)</li><li>Serial peripherals: I2C, SPI, and USART</li></ul></section><section><img data-src="figs/atmega328-pinout.png"></section><section><h2>Responding to changes</h2><h4>The polling approach</h4><pre><code class="cpp">void loop()
{
  if (digitalRead(BUTTON_PIN) == LOW)
  {
    Serial.println("Button pressed");
  }
  // Other tasks here
}</code></pre><div class="lefthalf"><p><span class="green">Pros</span>:</p><ul><li>Simple to reason about</li><li>Simple to program</li></ul></div><div class="righthalf"><p><span class="red">Cons</span>:</p><ul><li>Delayed response</li><li>Inefficient</li><li>No priority control</li></ul></div></section><section><h2>Responding to Changes</h2><h4>The Interrupt-driven Approach</h4><pre><code class="cpp">// TODO button interrupt example</code></pre></section><section><h2>Internal and External Interrupts</h2><p>TODO discuss the difference (priorities next slide)</p><p>TODO AVR designations - PCINT0,1,2 go with PORTB,C,D</p><p>TODO explain why Arduino pins 2,3 are special</p><p>Guidelines</p><ul><li>keep short and sweet</li><li>put sensitive code in a noInterrupts()/interrupts() block</li><li>(like AVR's ATOMIC_BLOCK, the most epic preprocessor definition ever)</li></ul></section><section><img data-src="figs/interrupt-priorities.png"></section><section><p><code>delay()</code></p><p>Think of the spinning beach ball or the hourglass on your OS...there are better alternatives.</p><p>TODO example of timeMarker idiom, also possibly loop_until_bit_is_set() macro</p><p>TODO mention elapsedMillis() and elapsedMicros() for teensy</p></section><section><h2>AVR Programming</h2><p>Why defeat Arduino's hardware abstraction?</p><div class="lefthalf"><p><span class="green">Pros</span>:</p><ul><li>Fine-grained control</li><li>Significant performance gains</li><li>Transparency: WYSIWYG bare-metal code</li></ul></div><div class="righthalf"><p><span class="red">Cons</span>:</p><ul><li>Non-portable</li><li>Looks esoteric</li><li>Mixing APIs</li></ul></div></section><section><h2>ATMega timer configuration</h2><p>Let's say you wish to output a PWM frequency other than the default</p><p>PWM pins: 5, 6 (Timer 0); 9, 10 (Timer 1); 3, 11 (Timer 2).</p><p>Base frequencies: 31350 Hz on 3, 9, 10, and 11; ~62.5 kHz on 5, 6.</p><p>Reconfiguring Timer 1 does not affect millis() or delay().</p><p>Default PWM frequencies are ~490 Hz, except for 5,6 at 980 Hz.</p></section><section><h2>Speeding up GPIO</h2><h4>Direct register i/o versus arduino</h4><p>AVR register R/W takes 1 instruction ($\lt$ 0.1 $\mu$s @ 16MHz)!</p><p><code class="cpp">digitalRead/Write</code> can take 50 cycles or more (4-5 us)</p><aside class="notes"><p>A few us often doesn't matter, but this may be enough to get you through a hotspot in your code.</p><p>Why dR and dW are slow:</p><ul><li>Function call overhead (stack address lookup)</li><li>Check if the pin is on a timer</li><li>Array lookup 1: integer pin number to port number (flash access)</li><li>Array lookup 2: port and pin number to register address (flash access)</li></ul><p>see http://www.codeproject.com/Articles/589299/Why-is-the-digital-I-O-in-Arduino-slow-and-what-ca</p></aside></section><section><h2>Math tips</h2><ul><li>Floating-point math is slow and inefficient on AVRs (no hardware FPU).</li><li>Beware: some Arduino functions (e.g. p <code class="cpp">map</code>) use integer division internally</li><li>Scale up your ints to keep precision:</li></ul><pre><code class="cpp">// convert ADC from a turnpot to an angle in degrees
float angle = (float)map(adc, ADC_FULL_LEFT, ADC_FULL_RIGHT, 100*DEG_FULL_LEFT, 100*DEG_FULL_RIGHT)/100;</code></pre></section><section><p style="text-align: center"><span class="ino-teal"><strong><code>analogRead</code> and Noise</strong></span></p><p>Low-pass filtering is easily implemented in firmware! Consider the <a href="http://www.itl.nist.gov/div898/handbook/pmc/section4/pmc431.htm">EWMA </a> for time-series ADC measurements $y_{t}$:</p><p>$$ S_t = \alpha y_{t−1} + (1−\alpha) S_{t−1} \quad 0 \lt \alpha \leq 1 \quad t \geq 3 $$</p><p>Let's implement this with $\alpha = 1/16$ using integer math:</p><pre><code class="cpp">void ewma(unsigned int x, unsigned int &x16)
{
 x16 = x + x16 - ((x16 - 8) >> 4);
}</code></pre><p>This improves precision: we work with $16S_t$ instead of $S_t$</p><p>$$ 16S_t = y_{t−1} + 16S_{t−1} - (16S_{t−1} - 16/2)/16 $$</p><p>then divide later when reporting the measurement.</p></section><section><p>[TODO: add plot of raw and smoothed ADC readings]</p></section><section><h2>Takeaways</h2><ul><li>HW abstraction is a great thing...</li><li>But (judiciously) busting it is useful!</li><li>Stop thinking of your MCU as just a CPU with i/o pins! Program the timer/counters and interrupt system too.</li><li>Arduino is not played out - the latest devices are still targeting the platform.</li></ul><p style="text-align: center">Thanks!!</p></section></div></div><script src="reveal.js/lib/js/head.min.js"></script><script src="reveal.js/js/reveal.js"></script><script src="init.js"></script></body></html>